{-# LANGUAGE OverloadedStrings #-}
module Data.DTA.Serialize.RB3 where

import Control.Applicative ((<$>), (<*>))
import Control.Monad ((>=>))

import qualified Data.ByteString.Char8 as B8

import Data.DTA.Serialize
import Data.DTA.Serialize.Magma (Gender(..))

<%
def makeRecord(name, fields)
  fields = fields.map do |f|
    if f[1].nil? or f[1].empty?
      f = f.dup
      f[1] = f[0].gsub(/_([a-z])/) { $1.upcase }
      f
    else
      f
    end
  end

  records = fields.map do |f|
    str = "#{f[1]} :: #{f[2]}"
    str += " {- ^ #{f[3]} -}" if f[3]
    str
  end
  deriving = 'deriving (Eq, Ord, Read, Show)'
  data = "data #{name} = #{name} { #{records.join(', ')} } #{deriving}"

  to_records = fields.map { |f| "(#{f[0].inspect}, toChunks $ #{f[1]} x)" }
  to_defn = "toChunks x = makeDict' [ #{to_records.join(', ')} ]"
  to_instance = "instance ToChunks #{name} where { #{to_defn} }"

  from_records =
    fields.map { |f| "(dictLookup #{f[0].inspect} d >>= fromChunks)" }
  from_defn =
    "fromChunks = getDict >=> \\d -> #{name} <$> #{from_records.join(' <*> ')}"
  from_instance = "instance FromChunks #{name} where { #{from_defn} }"

  [data, to_instance, from_instance].join("\n\n")
end

def makeEnum(name, fields)
  fields = fields.map do |f|
    if f[1].nil? or f[1].empty?
      f = f.dup
      f[1] = f[0].gsub(/(^|_)([a-z])/) { $2.upcase }
      f
    else
      f
    end
  end

  records = fields.map do |f|
    str = f[1]
    str += " {- ^ #{f[2]} -}" if f[2]
    str
  end
  deriving = 'deriving (Eq, Ord, Read, Show, Enum, Bounded)'
  data = "data #{name} = #{records.join(' | ')} #{deriving}"

  to_lines = fields.map { |f| "toChunks #{f[1]} = [Key #{f[0].inspect}]" }
  to_instance = "instance ToChunks #{name} where { #{to_lines.join('; ')} }"

  from_lines = fields.map { |f| "fromChunks [Key #{f[0].inspect}] = Right #{f[1]}" }
  from_lines << "fromChunks cs = Left $ \"Couldn't read as #{name}: \" ++ show cs"
  from_instance = "instance FromChunks #{name} where { #{from_lines.join('; ')} }"

  [data, to_instance, from_instance].join("\n\n")
end
%>

<%= makeRecord('SongPackage', [
  ['name'               , nil, 'B8.ByteString'],
  ['artist'             , nil, 'B8.ByteString'],
  ['master'             , nil, 'Bool'],
  ['song'               , nil, 'Song'],
  ['song_scroll_speed'  , nil, 'Integer'],
  ['bank'               , nil, 'B8.ByteString'],
  ['anim_tempo'         , nil, 'Integer'],
  ['song_length'        , nil, 'Integer'],
  ['preview'            , nil, '(Integer, Integer)'],
  ['rank'               , nil, 'Dict Integer'],
  ['genre'              , nil, 'Keyword'],
  ['vocal_gender'       , nil, 'Gender'],
  ['version'            , nil, 'Integer'],
  ['format'             , nil, 'Integer'],
  ['album_art'          , nil, 'Bool'],
  ['year_released'      , nil, 'Integer'],
  ['rating'             , nil, 'Integer'],
  ['sub_genre'          , nil, 'Keyword'],
  ['song_id'            , nil, 'Either Integer Keyword'],
  ['tuning_offset_cents', nil, 'Float'],
  ['guide_pitch_volume' , nil, 'Float'],
  ['game_origin'        , nil, 'Keyword'],
  ['encoding'           , nil, 'Keyword'],
  ['album_name'         , nil, 'B8.ByteString'],
  ['album_track_number' , nil, 'Integer'],
  ]) %>

<%= makeRecord('Song', [
  ['name'          , 'songName', 'B8.ByteString'                       ],
  ['tracks_count'  , nil       , 'InParens [Integer]'                  ],
  ['tracks'        , nil       , 'InParens (Dict (InParens [Integer]))'],
  ['pans'          , nil       , 'InParens [Float]'                    ],
  ['vols'          , nil       , 'InParens [Float]'                    ],
  ['cores'         , nil       , 'InParens [Integer]'                  ],
  ['vocal_parts'   , nil       , 'Integer'                             ],
  ['drum_solo'     , nil       , 'DrumSounds'                          ],
  ['drum_freestyle', nil       , 'DrumSounds'                          ],
  ]) %>

<%= makeRecord('DrumSounds', [
  ['seqs', nil, 'InParens [Keyword]'],
  ]) %>
